"""
SmartBugs dataset loader for real vulnerability labels.
Loads vulnerability labels from SmartBugs analysis results.
"""

import os
import json
import logging
from typing import Dict, List, Tuple, Optional
import pandas as pd
import hashlib

logger = logging.getLogger(__name__)


class SmartBugsLoader:
    """Load vulnerability labels from SmartBugs dataset."""
    
    def __init__(self, smartbugs_dir: Optional[str] = None):
        """
        Initialize SmartBugs loader.
        
        Args:
            smartbugs_dir: Directory containing SmartBugs results (optional)
        """
        self.smartbugs_dir = smartbugs_dir
        self.labels_cache = None
    
    def load_labels(self, smartbugs_dir: Optional[str] = None) -> Dict[str, int]:
        """
        Load vulnerability labels from SmartBugs results.
        
        Args:
            smartbugs_dir: Directory containing SmartBugs results (overrides init)
            
        Returns:
            Dictionary mapping contract identifier to label (1=vulnerable, 0=safe)
        """
        if smartbugs_dir:
            self.smartbugs_dir = smartbugs_dir
        
        if not self.smartbugs_dir or not os.path.exists(self.smartbugs_dir):
            logger.warning(f"SmartBugs directory not found: {self.smartbugs_dir}")
            return {}
        
        labels = {}
        
        # SmartBugs results are usually stored in results/ directory as JSON files
        results_dir = os.path.join(self.smartbugs_dir, 'results')
        
        if not os.path.exists(results_dir):
            # Try alternative structure: direct JSON files
            logger.info(f"Trying alternative structure in {self.smartbugs_dir}")
            labels.update(self._load_from_directory(self.smartbugs_dir))
        else:
            # Each tool has its own directory
            for tool in ['slither', 'mythril', 'securify', 'oyente', 'manticore']:
                tool_dir = os.path.join(results_dir, tool)
                if os.path.exists(tool_dir):
                    labels.update(self._load_tool_results(tool_dir, tool))
        
        # Cache labels
        self.labels_cache = labels
        
        logger.info(f"Loaded {len(labels)} labels from SmartBugs")
        vulnerable_count = sum(1 for v in labels.values() if v == 1)
        logger.info(f"  - Vulnerable: {vulnerable_count}")
        logger.info(f"  - Safe: {len(labels) - vulnerable_count}")
        
        return labels
    
    def _load_from_directory(self, directory: str) -> Dict[str, int]:
        """Load labels from a directory of JSON files."""
        labels = {}
        
        for filename in os.listdir(directory):
            if not filename.endswith('.json'):
                continue
            
            filepath = os.path.join(directory, filename)
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # Extract contract identifier (filename without extension)
                contract_id = filename.replace('.json', '')
                
                # Check if vulnerabilities were detected
                is_vulnerable = self._has_vulnerabilities(data, 'auto')
                labels[contract_id] = 1 if is_vulnerable else 0
                
            except Exception as e:
                logger.debug(f"Error loading {filepath}: {e}")
                continue
        
        return labels
    
    def _load_tool_results(self, tool_dir: str, tool_name: str) -> Dict[str, int]:
        """Load results from a specific tool."""
        labels = {}
        
        for filename in os.listdir(tool_dir):
            if not filename.endswith('.json'):
                continue
            
            filepath = os.path.join(tool_dir, filename)
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # Extract contract identifier (filename without extension)
                contract_id = filename.replace('.json', '')
                
                # Check if vulnerabilities were detected
                is_vulnerable = self._has_vulnerabilities(data, tool_name)
                
                # Use OR logic: if any tool finds vulnerability, mark as vulnerable
                if contract_id in labels:
                    labels[contract_id] = max(labels[contract_id], 1 if is_vulnerable else 0)
                else:
                    labels[contract_id] = 1 if is_vulnerable else 0
                
            except Exception as e:
                logger.debug(f"Error loading {filepath}: {e}")
                continue
        
        return labels
    
    def _has_vulnerabilities(self, data: dict, tool_name: str) -> bool:
        """Check if data contains vulnerability detections."""
        if not isinstance(data, dict):
            return False
        
        # Try different formats
        if tool_name == 'slither' or 'slither' in str(data).lower():
            # Slither format: {"results": [...]}
            if 'results' in data:
                return len(data['results']) > 0
            # Alternative: {"detectors": [...]}
            if 'detectors' in data:
                return len(data['detectors']) > 0
        
        elif tool_name == 'mythril' or 'mythril' in str(data).lower():
            # Mythril format: {"issues": [...]}
            if 'issues' in data:
                return len(data['issues']) > 0
        
        elif tool_name == 'securify' or 'securify' in str(data).lower():
            # Securify format: {"results": [...]}
            if 'results' in data:
                return len(data['results']) > 0
        
        elif tool_name == 'oyente' or 'oyente' in str(data).lower():
            # Oyente format: {"errors": [...]}
            if 'errors' in data:
                return len(data['errors']) > 0
        
        # Generic check: look for common vulnerability indicators
        vulnerability_keywords = [
            'vulnerability', 'vulnerable', 'issue', 'error', 
            'warning', 'detected', 'finding', 'result'
        ]
        
        for key in data.keys():
            if any(kw in key.lower() for kw in vulnerability_keywords):
                value = data[key]
                if isinstance(value, list) and len(value) > 0:
                    return True
                if isinstance(value, dict) and len(value) > 0:
                    return True
        
        return False
    
    def match_contracts_to_labels(
        self, 
        contracts: List[str], 
        contract_ids: Optional[List[str]] = None,
        labels: Optional[Dict[str, int]] = None
    ) -> List[int]:
        """
        Match contracts to SmartBugs labels.
        
        Args:
            contracts: List of contract code strings
            contract_ids: List of contract identifiers (e.g., filenames, hashes)
            labels: Dictionary of contract_id -> label (uses cache if None)
        
        Returns:
            List of labels corresponding to contracts
        """
        if labels is None:
            labels = self.labels_cache or {}
        
        if not labels:
            logger.warning("No labels available. Returning all zeros (safe).")
            return [0] * len(contracts)
        
        matched_labels = []
        
        # If contract_ids not provided, generate from contract hashes
        if contract_ids is None:
            contract_ids = [self._hash_contract(contract) for contract in contracts]
        
        for i, contract_id in enumerate(contract_ids):
            # Try exact match
            if contract_id in labels:
                matched_labels.append(labels[contract_id])
            else:
                # Try partial match (filename without extension, hash, etc.)
                matched = False
                for key in labels.keys():
                    # Check if contract_id is substring of key or vice versa
                    if contract_id in key or key in contract_id:
                        matched_labels.append(labels[key])
                        matched = True
                        break
                
                if not matched:
                    # Default to safe if no match found
                    matched_labels.append(0)
                    logger.debug(f"No label found for contract {i}: {contract_id[:20]}...")
        
        vulnerable_count = sum(matched_labels)
        logger.info(f"Matched labels: {vulnerable_count} vulnerable, "
                   f"{len(matched_labels) - vulnerable_count} safe")
        
        return matched_labels
    
    def _hash_contract(self, contract: str) -> str:
        """Generate hash identifier for a contract."""
        return hashlib.md5(contract.encode('utf-8')).hexdigest()[:16]
    
    def load_from_csv(self, csv_path: str) -> Dict[str, int]:
        """
        Load labels from a CSV file.
        
        Args:
            csv_path: Path to CSV file with columns: contract_id, label or vulnerable
        
        Returns:
            Dictionary mapping contract_id to label
        """
        try:
            df = pd.read_csv(csv_path)
            
            # Find label column
            label_col = None
            id_col = None
            
            for col in df.columns:
                col_lower = col.lower()
                if 'label' in col_lower or 'vulnerable' in col_lower or 'vuln' in col_lower:
                    label_col = col
                if 'id' in col_lower or 'contract' in col_lower or 'address' in col_lower:
                    id_col = col
            
            if label_col is None or id_col is None:
                raise ValueError(f"Could not find label or ID column in CSV. Columns: {df.columns.tolist()}")
            
            labels = {}
            for _, row in df.iterrows():
                contract_id = str(row[id_col])
                label = int(row[label_col]) if pd.notna(row[label_col]) else 0
                labels[contract_id] = label
            
            logger.info(f"Loaded {len(labels)} labels from CSV: {csv_path}")
            return labels
            
        except Exception as e:
            logger.error(f"Error loading CSV: {e}")
            return {}

