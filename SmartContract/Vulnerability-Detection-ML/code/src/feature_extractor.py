"""
Feature extraction module for smart contracts.
Extracts opcode frequency and AST node patterns from Solidity code.
"""

import re
import subprocess
import tempfile
import os
import sys
from typing import List, Dict, Any
import numpy as np
import logging
from collections import Counter

# Try to import Slither feature extractor
try:
    from slither_extractor import SlitherFeatureExtractor
    SLITHER_AVAILABLE = True
except ImportError:
    SLITHER_AVAILABLE = False

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class FeatureExtractor:
    """Extracts features from Solidity smart contracts."""
    
    def __init__(self, use_slither: bool = True):
        """
        Initialize the feature extractor.
        
        Args:
            use_slither: Whether to use Slither for enhanced features (default: True)
                        Set to False to skip Slither and use basic features only (much faster)
        """
        self.opcode_list = [
            'CALL', 'CALLCODE', 'DELEGATECALL', 'STATICCALL',
            'SSTORE', 'SLOAD', 'MSTORE', 'MLOAD',
            'PUSH', 'POP', 'DUP', 'SWAP',
            'ADD', 'SUB', 'MUL', 'DIV', 'MOD',
            'LT', 'GT', 'EQ', 'ISZERO',
            'JUMP', 'JUMPI', 'JUMPDEST',
            'REVERT', 'RETURN', 'STOP',
            'BALANCE', 'CALLVALUE', 'CALLDATALOAD',
            'LOG0', 'LOG1', 'LOG2', 'LOG3', 'LOG4',
            'CREATE', 'CREATE2', 'SELFDESTRUCT'
        ]
        
        self.ast_node_types = [
            'FunctionDefinition', 'ModifierDefinition', 'EventDefinition',
            'VariableDeclaration', 'Assignment', 'IfStatement',
            'ForStatement', 'WhileStatement', 'ReturnStatement',
            'FunctionCall', 'MemberAccess', 'BinaryOperation',
            'UnaryOperation', 'Conditional', 'IndexAccess',
            'Mapping', 'ArrayTypeName', 'StructDefinition',
            'ContractDefinition', 'InheritanceSpecifier', 'UsingForDirective'
        ]
        
        # Initialize Slither feature extractor if available and requested
        if use_slither and SLITHER_AVAILABLE:
            self.slither_extractor = SlitherFeatureExtractor()
            logger.info("Slither feature extractor initialized")
        else:
            self.slither_extractor = None
            if not use_slither:
                logger.info("Slither disabled. Using basic features only (faster execution).")
            else:
                logger.info("Slither not available. Using basic features only.")
    
    def extract_features(self, contracts: List[str]) -> np.ndarray:
        """
        Extract features from a list of contracts.
        
        Args:
            contracts: List of Solidity contract code strings
            
        Returns:
            numpy array of shape (n_contracts, n_features)
        """
        print(f"[FEATURE EXTRACTOR] Extracting features from {len(contracts)} contracts", flush=True)
        print("[FEATURE EXTRACTOR] This may take a while depending on the number of contracts...", flush=True)
        logger.info(f"Extracting features from {len(contracts)} contracts")
        logger.info("This may take a while depending on the number of contracts...")
        sys.stdout.flush()  # Ensure immediate output
        
        features = []
        start_time = None
        import time
        start_time = time.time()
        
        for i, contract in enumerate(contracts):
            # Progress update every 50 contracts for better visibility
            if (i + 1) % 50 == 0 or i == 0:
                progress_pct = (i + 1) / len(contracts) * 100
                elapsed = time.time() - start_time if start_time else 0
                if i > 0:
                    avg_time_per_contract = elapsed / (i + 1)
                    remaining = avg_time_per_contract * (len(contracts) - i - 1)
                    msg = f"[FEATURE EXTRACTOR] Progress: {i + 1}/{len(contracts)} contracts ({progress_pct:.1f}%) | Elapsed: {elapsed:.1f}s | Est. remaining: {remaining:.1f}s"
                    print(msg, flush=True)
                    logger.info(f"  Progress: {i + 1}/{len(contracts)} contracts ({progress_pct:.1f}%) | "
                              f"Elapsed: {elapsed:.1f}s | Est. remaining: {remaining:.1f}s")
                else:
                    print("[FEATURE EXTRACTOR] Starting feature extraction...", flush=True)
                    logger.info(f"  Starting feature extraction...")
                sys.stdout.flush()  # Ensure immediate output
            
            contract_features = self._extract_single_contract_features(contract, i + 1, len(contracts))
            features.append(contract_features)
        
        total_time = time.time() - start_time if start_time else 0
        logger.info(f"âœ“ Completed feature extraction for all {len(contracts)} contracts in {total_time:.1f} seconds")
        sys.stdout.flush()
        
        feature_matrix = np.array(features)
        logger.info(f"Extracted features shape: {feature_matrix.shape}")
        return feature_matrix
    
    def _extract_single_contract_features(self, contract: str, contract_num: int = 0, total: int = 0) -> List[float]:
        """
        Extract features from a single contract.
        
        Args:
            contract: Solidity contract code string
            
        Returns:
            List of feature values
        """
        features = []
        
        # Extract opcode frequency features
        opcode_features = self._extract_opcode_features(contract)
        features.extend(opcode_features)
        
        # Extract AST node features
        ast_features = self._extract_ast_features(contract)
        features.extend(ast_features)
        
        # Extract control flow patterns
        control_flow_features = self._extract_control_flow_features(contract)
        features.extend(control_flow_features)
        
        # Extract code metrics
        code_metrics = self._extract_code_metrics(contract)
        features.extend(code_metrics)
        
        # Extract Slither features if available
        if self.slither_extractor:
            try:
                # Slither compilation can be slow, show progress for every 10th contract
                if contract_num > 0 and contract_num % 10 == 0:
                    logger.debug(f"  Processing contract {contract_num}/{total} with Slither...")
                    sys.stdout.flush()
                slither_features = self.slither_extractor.extract_features(contract)
                features.extend(slither_features)
            except Exception as e:
                logger.debug(f"Slither feature extraction failed for contract {contract_num}: {e}")
                # Add zero-filled features if Slither fails
                if self.slither_extractor:
                    features.extend([0.0] * self.slither_extractor.get_feature_count())
        else:
            # Add zero-filled features if Slither not available
            if SLITHER_AVAILABLE:
                # This shouldn't happen, but just in case
                features.extend([0.0] * 39)  # 39 is the Slither feature count
        
        return features
    
    def _extract_opcode_features(self, contract: str) -> List[float]:
        """
        Extract opcode frequency features.
        Tries to compile and get opcodes, falls back to pattern matching.
        """
        opcode_counts = {opcode: 0 for opcode in self.opcode_list}
        
        # Try to get opcodes from compiled bytecode if possible
        try:
            compiled_opcodes = self._get_opcodes_from_compilation(contract)
            if compiled_opcodes:
                for opcode in compiled_opcodes:
                    opcode_upper = opcode.upper()
                    for key in opcode_counts.keys():
                        if key in opcode_upper:
                            opcode_counts[key] += 1
        except Exception as e:
            logger.debug(f"Could not compile contract for opcodes: {e}")
        
        # Pattern-based extraction as fallback
        contract_upper = contract.upper()
        
        # Count CALL patterns
        opcode_counts['CALL'] += len(re.findall(r'\bcall\b', contract_upper))
        opcode_counts['DELEGATECALL'] += len(re.findall(r'\bdelegatecall\b', contract_upper))
        opcode_counts['STATICCALL'] += len(re.findall(r'\bstaticcall\b', contract_upper))
        
        # Count storage operations
        opcode_counts['SSTORE'] += len(re.findall(r'\b(storage|mapping|struct)\b', contract_upper))
        opcode_counts['SLOAD'] += len(re.findall(r'\b(storage|mapping)\b', contract_upper))
        
        # Count arithmetic operations
        opcode_counts['ADD'] += len(re.findall(r'\+', contract))
        opcode_counts['SUB'] += len(re.findall(r'-', contract))
        opcode_counts['MUL'] += len(re.findall(r'\*', contract))
        opcode_counts['DIV'] += len(re.findall(r'/', contract))
        opcode_counts['MOD'] += len(re.findall(r'%', contract))
        
        # Count comparison operations
        opcode_counts['LT'] += len(re.findall(r'<', contract))
        opcode_counts['GT'] += len(re.findall(r'>', contract))
        opcode_counts['EQ'] += len(re.findall(r'==', contract))
        
        # Count control flow
        opcode_counts['JUMP'] += len(re.findall(r'\b(if|else|for|while|return)\b', contract_upper))
        opcode_counts['REVERT'] += len(re.findall(r'\b(revert|require|assert)\b', contract_upper))
        
        # Normalize by contract length
        contract_length = len(contract.split())
        if contract_length > 0:
            opcode_features = [opcode_counts[op] / contract_length for op in self.opcode_list]
        else:
            opcode_features = [0.0] * len(self.opcode_list)
        
        return opcode_features
    
    def _get_opcodes_from_compilation(self, contract: str) -> List[str]:
        """Try to compile contract and extract opcodes (requires solc)."""
        try:
            # Create temporary file
            with tempfile.NamedTemporaryFile(mode='w', suffix='.sol', delete=False) as f:
                f.write(contract)
                temp_path = f.name
            
            # Try to compile (this requires solc to be installed)
            result = subprocess.run(
                ['solc', '--opcodes', temp_path],
                capture_output=True,
                text=True,
                timeout=5
            )
            
            os.unlink(temp_path)
            
            if result.returncode == 0:
                # Extract opcodes from output
                opcodes = re.findall(r'\b([A-Z][A-Z0-9]+)\b', result.stdout)
                return opcodes
            
        except (subprocess.TimeoutExpired, FileNotFoundError, Exception):
            pass
        
        return []
    
    def _extract_ast_features(self, contract: str) -> List[float]:
        """
        Extract AST node pattern features.
        Uses pattern matching to approximate AST node counts.
        """
        ast_counts = {node_type: 0 for node_type in self.ast_node_types}
        
        contract_lower = contract.lower()
        
        # Function definitions
        ast_counts['FunctionDefinition'] = len(re.findall(r'\bfunction\s+\w+', contract))
        
        # Modifiers
        ast_counts['ModifierDefinition'] = len(re.findall(r'\bmodifier\s+\w+', contract))
        
        # Events
        ast_counts['EventDefinition'] = len(re.findall(r'\bevent\s+\w+', contract))
        
        # Variable declarations
        ast_counts['VariableDeclaration'] = len(re.findall(r'\b(uint|int|bool|string|address|bytes)\s+\w+', contract))
        
        # Assignments
        ast_counts['Assignment'] = len(re.findall(r'=', contract))
        
        # Control flow statements
        ast_counts['IfStatement'] = len(re.findall(r'\bif\s*\(', contract))
        ast_counts['ForStatement'] = len(re.findall(r'\bfor\s*\(', contract))
        ast_counts['WhileStatement'] = len(re.findall(r'\bwhile\s*\(', contract))
        ast_counts['ReturnStatement'] = len(re.findall(r'\breturn\b', contract))
        
        # Function calls
        ast_counts['FunctionCall'] = len(re.findall(r'\w+\s*\(', contract))
        
        # Member access
        ast_counts['MemberAccess'] = len(re.findall(r'\.\w+', contract))
        
        # Binary operations
        ast_counts['BinaryOperation'] = len(re.findall(r'[+\-*/%&|^<>]', contract))
        
        # Unary operations
        ast_counts['UnaryOperation'] = len(re.findall(r'[!~]', contract))
        
        # Conditionals
        ast_counts['Conditional'] = len(re.findall(r'\?', contract))
        
        # Index access
        ast_counts['IndexAccess'] = len(re.findall(r'\[', contract))
        
        # Mappings
        ast_counts['Mapping'] = len(re.findall(r'\bmapping\s*\(', contract))
        
        # Arrays
        ast_counts['ArrayTypeName'] = len(re.findall(r'\[\]', contract))
        
        # Structs
        ast_counts['StructDefinition'] = len(re.findall(r'\bstruct\s+\w+', contract))
        
        # Contracts
        ast_counts['ContractDefinition'] = len(re.findall(r'\bcontract\s+\w+', contract))
        
        # Inheritance
        ast_counts['InheritanceSpecifier'] = len(re.findall(r'\bis\s+\w+', contract))
        
        # Using for
        ast_counts['UsingForDirective'] = len(re.findall(r'\busing\s+\w+\s+for', contract))
        
        # Normalize by contract length
        contract_length = len(contract.split())
        if contract_length > 0:
            ast_features = [ast_counts[node] / contract_length for node in self.ast_node_types]
        else:
            ast_features = [0.0] * len(self.ast_node_types)
        
        return ast_features
    
    def _extract_control_flow_features(self, contract: str) -> List[float]:
        """Extract control flow pattern features."""
        features = []
        
        # Depth of nested if statements
        max_if_depth = self._calculate_max_nesting_depth(contract, 'if')
        features.append(max_if_depth)
        
        # Number of loops
        loop_count = len(re.findall(r'\b(for|while)\s*\(', contract))
        features.append(loop_count)
        
        # Number of require/assert statements
        require_count = len(re.findall(r'\b(require|assert)\s*\(', contract))
        features.append(require_count)
        
        # Number of external calls
        external_call_count = len(re.findall(r'\.(call|delegatecall|staticcall|transfer|send)\s*\(', contract))
        features.append(external_call_count)
        
        # Number of state variable accesses
        state_var_count = len(re.findall(r'\b(this\.|self\.)', contract))
        features.append(state_var_count)
        
        # Normalize by contract length
        contract_length = len(contract.split())
        if contract_length > 0:
            features = [f / contract_length for f in features]
        else:
            features = [0.0] * len(features)
        
        return features
    
    def _calculate_max_nesting_depth(self, contract: str, keyword: str) -> float:
        """Calculate maximum nesting depth of a keyword."""
        lines = contract.split('\n')
        max_depth = 0
        current_depth = 0
        
        for line in lines:
            if re.search(rf'\b{keyword}\s*\(', line):
                current_depth += 1
                max_depth = max(max_depth, current_depth)
            # Simple heuristic: closing braces decrease depth
            if '}' in line:
                current_depth = max(0, current_depth - 1)
        
        return float(max_depth)
    
    def _extract_code_metrics(self, contract: str) -> List[float]:
        """Extract code metric features."""
        features = []
        
        # Contract length (lines)
        lines = contract.split('\n')
        features.append(len(lines))
        
        # Contract length (characters)
        features.append(len(contract))
        
        # Contract length (words)
        words = contract.split()
        features.append(len(words))
        
        # Average line length
        if len(lines) > 0:
            avg_line_length = sum(len(line) for line in lines) / len(lines)
        else:
            avg_line_length = 0.0
        features.append(avg_line_length)
        
        # Number of functions
        function_count = len(re.findall(r'\bfunction\s+\w+', contract))
        features.append(function_count)
        
        # Number of state variables
        state_var_count = len(re.findall(r'\b(public|private|internal|external)\s+(uint|int|bool|string|address|bytes)', contract))
        features.append(state_var_count)
        
        # Number of comments
        comment_count = len(re.findall(r'//|/\*|\*/', contract))
        features.append(comment_count)
        
        # Normalize large values
        features = [min(f, 10000) / 1000.0 for f in features]  # Normalize to 0-10 range
        
        return features
    
    def get_feature_names(self) -> List[str]:
        """Get list of feature names."""
        feature_names = []
        
        # Opcode features
        feature_names.extend([f"opcode_{op}" for op in self.opcode_list])
        
        # AST features
        feature_names.extend([f"ast_{node}" for node in self.ast_node_types])
        
        # Control flow features
        feature_names.extend([
            "max_if_depth", "loop_count", "require_count",
            "external_call_count", "state_var_count"
        ])
        
        # Code metrics
        feature_names.extend([
            "num_lines", "num_chars", "num_words", "avg_line_length",
            "num_functions", "num_state_vars", "num_comments"
        ])
        
        # Slither features
        if self.slither_extractor:
            feature_names.extend(self.slither_extractor.get_feature_names())
        else:
            # Add placeholder names if Slither not available
            if SLITHER_AVAILABLE:
                from slither_extractor import SlitherFeatureExtractor
                temp_extractor = SlitherFeatureExtractor()
                feature_names.extend(temp_extractor.get_feature_names())
        
        return feature_names

