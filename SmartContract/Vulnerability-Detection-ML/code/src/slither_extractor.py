"""
Slither-based feature extraction for smart contracts.
Extracts static analysis features, CFG metrics, call graph metrics, etc.
"""

import os
import tempfile
import logging
from typing import List, Dict, Any
import numpy as np

try:
    import slither
    SLITHER_AVAILABLE = True
except ImportError:
    SLITHER_AVAILABLE = False
    logging.warning("Slither not available. Install with: pip install slither-analyzer")

logger = logging.getLogger(__name__)


class SlitherFeatureExtractor:
    """Extract features using Slither static analysis."""
    
    def __init__(self):
        self.available = SLITHER_AVAILABLE
        if not self.available:
            logger.warning("Slither not available. Features will be zero-filled.")
    
    def extract_features(self, contract_code: str) -> List[float]:
        """
        Extract features from contract using Slither.
        
        Args:
            contract_code: Solidity contract source code
            
        Returns:
            List of feature values (will be zero-filled if Slither unavailable)
        """
        if not self.available:
            return self._get_zero_features()
        
        # Create temporary file
        with tempfile.NamedTemporaryFile(mode='w', suffix='.sol', delete=False) as f:
            f.write(contract_code)
            temp_path = f.name
        
        try:
            # Try to analyze - catch exceptions quickly to avoid hanging
            # Many contracts will fail due to version incompatibilities, so we fail fast
            slither_obj = slither.Slither(temp_path, disable_solc_warnings=True)
            features = []
            
            # Extract different feature categories
            features.extend(self._extract_detector_features(slither_obj))
            features.extend(self._extract_cfg_features(slither_obj))
            features.extend(self._extract_call_graph_features(slither_obj))
            features.extend(self._extract_inheritance_features(slither_obj))
            features.extend(self._extract_function_features(slither_obj))
            features.extend(self._extract_variable_features(slither_obj))
            
            return features
        except Exception as e:
            # If Slither fails (compilation errors, version mismatches, etc.), return zeros immediately
            # Don't log every failure to avoid spam - most old contracts will fail
            return self._get_zero_features()
        finally:
            if os.path.exists(temp_path):
                try:
                    os.unlink(temp_path)
                except:
                    pass
    
    def _extract_detector_features(self, slither_obj) -> List[float]:
        """Extract detector-based features."""
        features = []
        
        # Common vulnerability detectors
        detector_names = [
            'reentrancy-eth', 'reentrancy-no-eth',
            'unchecked-transfer', 'unchecked-send',
            'tx-origin', 'suicidal', 'arbitrary-send',
            'controlled-delegatecall', 'uninitialized-state',
            'uninitialized-storage', 'unused-return'
        ]
        
        detector_results = {}
        for detector in slither_obj.detectors:
            detector_name = detector.ARGUMENT
            detector_results[detector_name] = len(detector.results)
        
        for name in detector_names:
            features.append(float(detector_results.get(name, 0)))
        
        return features
    
    def _extract_cfg_features(self, slither_obj) -> List[float]:
        """Extract Control Flow Graph features."""
        features = []
        
        total_nodes = 0
        total_edges = 0
        max_depth = 0
        total_branches = 0
        
        for contract in slither_obj.contracts:
            for function in contract.functions:
                if hasattr(function, 'cfg') and function.cfg:
                    nodes = function.cfg.nodes
                    total_nodes += len(nodes)
                    
                    # Count edges
                    edges = sum(len(node.sons) for node in nodes if hasattr(node, 'sons'))
                    total_edges += edges
                    
                    # Calculate depth (simplified)
                    depth = self._calculate_cfg_depth(nodes)
                    max_depth = max(max_depth, depth)
                    
                    # Count branch nodes
                    branches = sum(1 for node in nodes if hasattr(node, 'sons') and len(node.sons) > 1)
                    total_branches += branches
        
        features.extend([
            float(total_nodes),
            float(total_edges),
            float(max_depth),
            float(total_branches),
            float(total_edges / total_nodes) if total_nodes > 0 else 0.0  # Edge-to-node ratio
        ])
        
        return features
    
    def _extract_call_graph_features(self, slither_obj) -> List[float]:
        """Extract call graph features."""
        features = []
        
        external_calls = 0
        delegate_calls = 0
        static_calls = 0
        low_level_calls = 0
        recursive_calls = 0
        
        for contract in slither_obj.contracts:
            for function in contract.functions:
                # Count external calls
                if hasattr(function, 'external_calls'):
                    for call in function.external_calls:
                        external_calls += 1
                        if hasattr(call, 'type'):
                            if call.type == 'DELEGATECALL':
                                delegate_calls += 1
                            elif call.type == 'STATICCALL':
                                static_calls += 1
                
                # Count low-level calls
                if hasattr(function, 'low_level_calls'):
                    low_level_calls += len(function.low_level_calls)
                
                # Check for recursion (simplified)
                if hasattr(function, 'internal_calls'):
                    internal_call_names = [f.name for f in function.internal_calls if hasattr(f, 'name')]
                    if function.name in internal_call_names:
                        recursive_calls += 1
        
        features.extend([
            float(external_calls),
            float(delegate_calls),
            float(static_calls),
            float(low_level_calls),
            float(recursive_calls)
        ])
        
        return features
    
    def _extract_inheritance_features(self, slither_obj) -> List[float]:
        """Extract inheritance graph features."""
        features = []
        
        max_inheritance_depth = 0
        total_contracts = len(slither_obj.contracts)
        multiple_inheritance_count = 0
        
        for contract in slither_obj.contracts:
            # Calculate inheritance depth
            depth = self._calculate_inheritance_depth(contract)
            max_inheritance_depth = max(max_inheritance_depth, depth)
            
            # Check for multiple inheritance
            if hasattr(contract, 'inheritance') and len(contract.inheritance) > 1:
                multiple_inheritance_count += 1
        
        features.extend([
            float(max_inheritance_depth),
            float(total_contracts),
            float(multiple_inheritance_count),
            float(multiple_inheritance_count / total_contracts) if total_contracts > 0 else 0.0
        ])
        
        return features
    
    def _extract_function_features(self, slither_obj) -> List[float]:
        """Extract function-level features."""
        features = []
        
        total_functions = 0
        public_functions = 0
        external_functions = 0
        payable_functions = 0
        view_functions = 0
        pure_functions = 0
        functions_with_modifiers = 0
        avg_params_per_function = 0
        
        param_counts = []
        
        for contract in slither_obj.contracts:
            for function in contract.functions:
                total_functions += 1
                
                if hasattr(function, 'visibility'):
                    if function.visibility == 'public':
                        public_functions += 1
                    elif function.visibility == 'external':
                        external_functions += 1
                
                if hasattr(function, 'is_payable') and function.is_payable:
                    payable_functions += 1
                if hasattr(function, 'is_view') and function.is_view:
                    view_functions += 1
                if hasattr(function, 'is_pure') and function.is_pure:
                    pure_functions += 1
                
                if hasattr(function, 'modifiers') and function.modifiers:
                    functions_with_modifiers += 1
                
                if hasattr(function, 'parameters'):
                    param_counts.append(len(function.parameters))
        
        if param_counts:
            avg_params_per_function = sum(param_counts) / len(param_counts)
        
        features.extend([
            float(total_functions),
            float(public_functions),
            float(external_functions),
            float(payable_functions),
            float(view_functions),
            float(pure_functions),
            float(functions_with_modifiers),
            float(avg_params_per_function)
        ])
        
        return features
    
    def _extract_variable_features(self, slither_obj) -> List[float]:
        """Extract variable-level features."""
        features = []
        
        total_variables = 0
        public_variables = 0
        private_variables = 0
        uninitialized_variables = 0
        mapping_variables = 0
        array_variables = 0
        
        for contract in slither_obj.contracts:
            for variable in contract.state_variables:
                total_variables += 1
                
                if hasattr(variable, 'visibility'):
                    if variable.visibility == 'public':
                        public_variables += 1
                    elif variable.visibility == 'private':
                        private_variables += 1
                
                if hasattr(variable, 'initialized') and not variable.initialized:
                    uninitialized_variables += 1
                
                if hasattr(variable, 'type'):
                    if hasattr(variable.type, 'is_mapping') and variable.type.is_mapping:
                        mapping_variables += 1
                    if hasattr(variable.type, 'is_array') and variable.type.is_array:
                        array_variables += 1
        
        features.extend([
            float(total_variables),
            float(public_variables),
            float(private_variables),
            float(uninitialized_variables),
            float(mapping_variables),
            float(array_variables)
        ])
        
        return features
    
    def _calculate_cfg_depth(self, nodes) -> int:
        """Calculate maximum depth of CFG (simplified BFS)."""
        if not nodes:
            return 0
        
        # Find entry node (node with no predecessors)
        entry_nodes = [n for n in nodes if hasattr(n, 'fathers') and not n.fathers]
        if not entry_nodes:
            entry_nodes = [nodes[0]] if nodes else []
        
        max_depth = 0
        for entry in entry_nodes:
            depth = self._bfs_depth(entry, set())
            max_depth = max(max_depth, depth)
        
        return max_depth
    
    def _bfs_depth(self, node, visited) -> int:
        """BFS to calculate depth."""
        if node in visited:
            return 0
        visited.add(node)
        
        if not hasattr(node, 'sons') or not node.sons:
            return 1
        
        max_child_depth = max(self._bfs_depth(son, visited.copy()) for son in node.sons)
        return 1 + max_child_depth
    
    def _calculate_inheritance_depth(self, contract) -> int:
        """Calculate inheritance depth."""
        if not hasattr(contract, 'inheritance') or not contract.inheritance:
            return 0
        
        max_depth = 0
        for parent in contract.inheritance:
            depth = self._calculate_inheritance_depth(parent) + 1
            max_depth = max(max_depth, depth)
        
        return max_depth
    
    def _get_zero_features(self) -> List[float]:
        """Return zero-filled feature vector."""
        return [0.0] * self.get_feature_count()
    
    def get_feature_count(self) -> int:
        """Get total number of features."""
        return (
            11 +  # detector features
            5 +   # CFG features
            5 +   # call graph features
            4 +   # inheritance features
            8 +   # function features
            6     # variable features
        )  # Total: 39 features
    
    def get_feature_names(self) -> List[str]:
        """Get names of all features."""
        names = []
        
        # Detector features
        detector_names = [
            'reentrancy-eth', 'reentrancy-no-eth',
            'unchecked-transfer', 'unchecked-send',
            'tx-origin', 'suicidal', 'arbitrary-send',
            'controlled-delegatecall', 'uninitialized-state',
            'uninitialized-storage', 'unused-return'
        ]
        names.extend([f"slither_detector_{n}" for n in detector_names])
        
        # CFG features
        names.extend([
            'slither_cfg_nodes', 'slither_cfg_edges', 'slither_cfg_max_depth',
            'slither_cfg_branches', 'slither_cfg_edge_node_ratio'
        ])
        
        # Call graph features
        names.extend([
            'slither_external_calls', 'slither_delegate_calls',
            'slither_static_calls', 'slither_low_level_calls',
            'slither_recursive_calls'
        ])
        
        # Inheritance features
        names.extend([
            'slither_max_inheritance_depth', 'slither_total_contracts',
            'slither_multiple_inheritance_count', 'slither_multiple_inheritance_ratio'
        ])
        
        # Function features
        names.extend([
            'slither_total_functions', 'slither_public_functions',
            'slither_external_functions', 'slither_payable_functions',
            'slither_view_functions', 'slither_pure_functions',
            'slither_functions_with_modifiers', 'slither_avg_params_per_function'
        ])
        
        # Variable features
        names.extend([
            'slither_total_variables', 'slither_public_variables',
            'slither_private_variables', 'slither_uninitialized_variables',
            'slither_mapping_variables', 'slither_array_variables'
        ])
        
        return names

