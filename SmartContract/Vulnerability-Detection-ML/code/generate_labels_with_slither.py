"""
Generate vulnerability labels using Slither static analysis.
Scans contract files and detects vulnerabilities to create binary labels.
"""

import os
import json
import sys
from pathlib import Path
from typing import Dict

try:
    import slither
    SLITHER_AVAILABLE = True
except ImportError:
    SLITHER_AVAILABLE = False
    print("ERROR: Slither is not installed.")
    print("Install with: pip install slither-analyzer")
    sys.exit(1)

import re

def detect_vulnerability_patterns(contract_code: str) -> bool:
    """
    Detect vulnerability patterns in contract code using pattern matching.
    Used as fallback when Slither compilation fails.
    
    Args:
        contract_code: Solidity contract source code
        
    Returns:
        True if vulnerability patterns detected, False otherwise
    """
    code_upper = contract_code.upper()
    vulnerability_score = 0
    
    # 1. Reentrancy patterns: external call before state update
    # Pattern: call/transfer/send followed by state variable update
    call_patterns = [
        r'\.call\s*\(',
        r'\.transfer\s*\(',
        r'\.send\s*\(',
        r'\.delegatecall\s*\('
    ]
    has_external_call = any(re.search(pattern, contract_code, re.IGNORECASE) for pattern in call_patterns)
    
    # Check for state updates after calls (simplified pattern)
    if has_external_call:
        # Look for state variable assignments
        state_update_patterns = [
            r'\b(mapping|storage)\s+',
            r'=\s*[^=]',  # Assignment
        ]
        has_state_updates = any(re.search(pattern, contract_code, re.IGNORECASE) for pattern in state_update_patterns)
        if has_state_updates:
            vulnerability_score += 2
    
    # 2. Unchecked external calls
    # Pattern: call without checking return value
    unchecked_call_pattern = r'\.(call|send|transfer)\s*\([^)]*\)\s*;'
    if re.search(unchecked_call_pattern, contract_code, re.IGNORECASE):
        # Check if there's no require/assert/if checking the result
        call_matches = list(re.finditer(unchecked_call_pattern, contract_code, re.IGNORECASE))
        for match in call_matches:
            # Check next 5 lines for require/assert/if
            next_lines = contract_code[match.end():match.end()+200]
            if not re.search(r'\b(require|assert|if)\s*\(', next_lines, re.IGNORECASE):
                vulnerability_score += 2
    
    # 3. tx.origin usage (vulnerable to phishing)
    if re.search(r'\btx\.origin\b', contract_code, re.IGNORECASE):
        vulnerability_score += 1
    
    # 4. delegatecall usage (dangerous if user-controlled)
    if re.search(r'\.delegatecall\s*\(', contract_code, re.IGNORECASE):
        vulnerability_score += 2
    
    # 5. selfdestruct usage
    if re.search(r'\b(selfdestruct|suicide)\s*\(', contract_code, re.IGNORECASE):
        vulnerability_score += 1
    
    # 6. Integer overflow patterns (pre-Solidity 0.8)
    # Pattern: arithmetic operations without SafeMath
    if re.search(r'pragma\s+solidity\s+[^0-9]*0\.[0-7]', contract_code, re.IGNORECASE):
        # Old Solidity version, check for arithmetic
        if re.search(r'[a-zA-Z_][a-zA-Z0-9_]*\s*[+\-*/]\s*[a-zA-Z_][a-zA-Z0-9_]*', contract_code):
            # Check if SafeMath is used
            if not re.search(r'\bSafeMath\b', contract_code, re.IGNORECASE):
                vulnerability_score += 1
    
    # 7. Uninitialized storage pointer
    if re.search(r'storage\s+\*\s*[a-zA-Z_]', contract_code, re.IGNORECASE):
        vulnerability_score += 1
    
    # 8. Dangerous low-level calls
    # Pattern: call with empty data or value
    dangerous_call = re.search(r'\.call\s*\(\s*["\']?\s*["\']?\s*\)', contract_code, re.IGNORECASE)
    if dangerous_call:
        vulnerability_score += 1
    
    # 9. Missing access control
    # Pattern: public/external function that modifies state without modifier
    public_functions = re.findall(r'function\s+[a-zA-Z_][a-zA-Z0-9_]*\s*\([^)]*\)\s+public', contract_code, re.IGNORECASE)
    external_functions = re.findall(r'function\s+[a-zA-Z_][a-zA-Z0-9_]*\s*\([^)]*\)\s+external', contract_code, re.IGNORECASE)
    
    # Check if these functions modify state
    for func_match in public_functions + external_functions:
        # Look for state modifications in function
        func_start = contract_code.find(func_match)
        if func_start != -1:
            # Find function body (simplified)
            func_body = contract_code[func_start:func_start+500]
            if re.search(r'\b(mapping|storage|=\s*[^=])', func_body, re.IGNORECASE):
                # Check for access control modifiers
                if not re.search(r'\b(onlyOwner|onlyAdmin|modifier)\b', func_body, re.IGNORECASE):
                    vulnerability_score += 1
                    break
    
    # Threshold: if score >= 2, consider vulnerable
    return vulnerability_score >= 2

def generate_labels_from_contracts(
    data_dir: str = "data",
    max_contracts: int = 2000,
    output_file: str = "labels_slither.json"
) -> Dict[str, int]:
    """
    Scan contract files and detect vulnerabilities using Slither to generate labels.
    
    Args:
        data_dir: Data directory path
        max_contracts: Maximum number of contracts to process
        output_file: Output JSON file path
        
    Returns:
        Dictionary mapping contract_id to label (0=safe, 1=vulnerable)
    """
    labels = {}
    contract_files = []
    
    # Find all .sol files (in the same order as DataLoader)
    dataset_path = os.path.join(data_dir, "Ethereum_smart_contract_datast", "contract_dataset_ethereum")
    
    if not os.path.exists(dataset_path):
        print(f"ERROR: Dataset path not found: {dataset_path}")
        sys.exit(1)
    
    print(f"Scanning for .sol files in {dataset_path}...")
    
    # Collect files in the same order as DataLoader
    # 1. Sort contract directories
    contract_dirs = [d for d in os.listdir(dataset_path) 
                     if os.path.isdir(os.path.join(dataset_path, d)) and d.startswith('contract')]
    contract_dirs.sort()  # contract1, contract2, ... order
    
    # 2. Collect .sol files from each directory (same order as DataLoader)
    for contract_dir in contract_dirs:
        if len(contract_files) >= max_contracts:
            break
        
        contract_dir_path = os.path.join(dataset_path, contract_dir)
        sol_files = [f for f in os.listdir(contract_dir_path) if f.endswith('.sol')]
        
        for sol_file in sol_files:
            if len(contract_files) >= max_contracts:
                break
            contract_files.append(os.path.join(contract_dir_path, sol_file))
    
    print(f"Found {len(contract_files)} contract files")
    print("Scanning for vulnerabilities with Slither...")
    print("This may take a while...")
    print()
    
    vulnerable_count = 0
    safe_count = 0
    error_count = 0
    
    import time
    start_time = time.time()
    
    for i, contract_path in enumerate(contract_files):
        # Progress update every 10 contracts for better visibility
        if (i + 1) % 10 == 0 or i == 0:
            elapsed = time.time() - start_time
            if i > 0:
                avg_time = elapsed / (i + 1)
                remaining = avg_time * (len(contract_files) - i - 1)
                progress_pct = (i + 1) / len(contract_files) * 100
                print(f"[LABEL GENERATOR] Progress: {i + 1}/{len(contract_files)} ({progress_pct:.1f}%) | "
                      f"Vulnerable: {vulnerable_count}, Safe: {safe_count}, Errors: {error_count} | "
                      f"Elapsed: {elapsed:.1f}s | Est. remaining: {remaining:.1f}s ({remaining/60:.1f} min)")
                sys.stdout.flush()
            else:
                print(f"[LABEL GENERATOR] Starting analysis of {len(contract_files)} contracts...")
                print(f"[LABEL GENERATOR] This may take 10-20 minutes. Progress will be shown every 10 contracts.")
                sys.stdout.flush()
        
        try:
            # Analyze with Slither
            slither_obj = slither.Slither(contract_path, disable_solc_warnings=True)
            
            # Check if vulnerabilities were detected
            has_vulnerability = False
            vulnerability_types = []
            
            for detector in slither_obj.detectors:
                if len(detector.results) > 0:
                    has_vulnerability = True
                    # Record only major vulnerability types
                    detector_name = getattr(detector, 'ARGUMENT', 'unknown')
                    if detector_name in ['reentrancy-eth', 'reentrancy-no-eth', 
                                        'unchecked-transfer', 'unchecked-send',
                                        'tx-origin', 'suicidal', 'arbitrary-send']:
                        vulnerability_types.append(detector_name)
            
            # Generate contract_id in the same format as DataLoader
            # Format: contract_dir_filename (e.g., "contract1_65")
            contract_dir = os.path.basename(os.path.dirname(contract_path))
            sol_file = os.path.basename(contract_path)
            contract_id = f"{contract_dir}_{sol_file.replace('.sol', '')}"
            
            labels[contract_id] = 1 if has_vulnerability else 0
            
            if has_vulnerability:
                vulnerable_count += 1
            else:
                safe_count += 1
                
        except Exception as e:
            # If Slither analysis fails, use pattern-based vulnerability detection
            try:
                with open(contract_path, 'r', encoding='utf-8', errors='ignore') as f:
                    contract_code = f.read()
                
                # Pattern-based vulnerability detection for contracts that fail to compile
                has_vulnerability = detect_vulnerability_patterns(contract_code)
                
                contract_dir = os.path.basename(os.path.dirname(contract_path))
                sol_file = os.path.basename(contract_path)
                contract_id = f"{contract_dir}_{sol_file.replace('.sol', '')}"
                
                labels[contract_id] = 1 if has_vulnerability else 0
                
                if has_vulnerability:
                    vulnerable_count += 1
                else:
                    safe_count += 1
                error_count += 1
            except Exception as e2:
                # If even reading fails, mark as safe
                contract_dir = os.path.basename(os.path.dirname(contract_path))
                sol_file = os.path.basename(contract_path)
                contract_id = f"{contract_dir}_{sol_file.replace('.sol', '')}"
                labels[contract_id] = 0
                safe_count += 1
                error_count += 1
            continue
    
    # Save to JSON file
    output_path = os.path.join(data_dir, output_file)
    with open(output_path, 'w') as f:
        json.dump(labels, f, indent=2)
    
    print()
    print("="*60)
    print("âœ“ Label generation complete!")
    print("="*60)
    print(f"  - Total contracts: {len(labels)}")
    print(f"  - Vulnerable: {vulnerable_count} ({100*vulnerable_count/len(labels):.1f}%)")
    print(f"  - Safe: {safe_count} ({100*safe_count/len(labels):.1f}%)")
    print(f"  - Errors: {error_count}")
    print(f"  - Saved to: {output_path}")
    print()
    print("Usage:")
    print(f"  python main.py --data-dir {data_dir} --max-contracts {max_contracts} --labels-file {output_file}")
    print("="*60)
    
    return labels

if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description='Generate vulnerability labels using Slither')
    parser.add_argument('--data-dir', type=str, default='data', help='Data directory')
    parser.add_argument('--max-contracts', type=int, default=2000, help='Max contracts to process')
    parser.add_argument('--output', type=str, default='labels_slither.json', help='Output JSON file')
    
    args = parser.parse_args()
    
    generate_labels_from_contracts(
        data_dir=args.data_dir,
        max_contracts=args.max_contracts,
        output_file=args.output
    )

